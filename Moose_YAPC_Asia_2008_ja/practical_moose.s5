Title:        Moose
Location:     YAPC::Asia::2008
Presenter:    Yuval Kogman
Date:         2008
Theme:        moose

Moose はなにではないか
======================
Moose Is Not
------------

* 実験やプロトタイプ (experimental)
* おもちゃ (toy)
* もう一つのアクセサビルダー (accessor builder)
* ソースフィルタ (source filter)
* 黒魔術 (black magic)
* Perl 6 in Perl 5

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseとはなにか
===============
Moose Is
--------

* Perlのための完全にモダンなオブジェクトフレームワーク

* A complete modern object framework for Perl

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseとはなにか
===============
Moose Is
--------

* Class::MOPのためのシンタックスシュガー (Syntactic sugar)
* 祖先たち (ancestry)
    * CLOS (Common Lisp Object System)
    * Smalltalk
    * Alces latifrons
    * Perl 6
    * …
* 安定していて、お仕事にもつかえます (Stable & Production ready)


✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

シンプルな例
============
A Simple Example
----------------

<pre><code>
package Person;

use strict;
use warnings;

sub new {
    my ($class) = @_;

    return bless {
        name => '',
        age  => undef,
    }, $class;
}

sub name {
    my ($self, $name) = @_;
    $self->{'name'} = $name if $name;
    return $self->{'name'};
}

sub age {
    my ($self, $age) = @_;
    $self->{'age'} = $age if $age;
    return $self->{'age'}; 
}

1;
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

シンプルなMooseの例
===================
A Simple Moose Example
----------------------

<pre><code>
package Person;
use Moose;

has name => (is => 'rw');
has age  => (is => 'rw');

1;
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

シンプルなMooseの例(つづき)
===========================
A Simple Moose Example (cont.)
------------------------------

* `use Moose;` 
    * キーワードをインポート (imports keywords)
    * `use strict; use warnings;`
    * `@ISA = qw(Moose::Object) unless @ISA`

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

シンプルなMooseの例(つづき)
===========================
A Simple Moose Example (cont.)
------------------------------

* `has` はアトリビュートを定義する (declares attibutes)
    * アクセサを生成 (generates accessors)
    * `is => 'rw'` → 読み書き両用アクセサ
    * `is => 'ro'` → 読み込み専用アクセサ
    * `writer`, `reader`

* `new` は `Moose::Object` から継承する


##########

今度はアトリビュートの機能を説明していくよ
Now we're going to discuss more features of the attributes

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseの例のバリエーション
=========================
Variations on a Moose Example
-----------------------------

<pre><code>
package Person;
use Moose;

has name => (
    is => 'rw', 
    isa => 'Str'
    default => 'Bob'
);

has staff => (
    is      => 'ro',
    isa     => 'ArrayRef',
    lazy    => 1,
    default => sub { [qw(Bob Alice Tim)] },
);
</code></pre>

##########

default と isa が追加されてます
Adds default, isa

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseの例のバリエーション(つづき)
=================================
Variations on a Moose Example (cont.)
-------------------------------------

* `default` は
    * コードリファレンス (coderef)
    * またはリファレンス以外 (数値, 文字列) (nonref)
    * `new` にパラメータがわたされなかったときに使われる

* `lazy` は `default` を遅延させる
    * 最初に `$object->staff` が使われたときに呼ばれる (generates)
    * `new` の中ではなく (no param)

##########
デフォルトの話
discusses default

リファレンスでないと想定外の共有がむずかしくなる
non refs make accidental sharing hard

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseの例のバリエーション(つづき)
=================================
Variations on a Moose Example (cont.)
-------------------------------------

* `isa` は型を規定する (specifies type)
    * `Moose::Util::TypeConstraints`
        * `Any, Item, Bool, Undef, Defined, Value, Num, Int, Str, Ref, ScalarRef, ArrayRef, HashRef, CodeRef, RegexpRef, GlobRef, FileHandle, Object, and Role`
    * 型は存在する必要はありません (don't need to exist)
<pre><code>
            has 'date' => (isa => 'DateTime'); # DWIM
</code></pre>
##########

isa, 型の制約
isa, type constraints

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

型
==
Typical Family
--------------

* 型は階層構造をもっている (types have a hierarchy)
    * `Item` ⊃ `Defined` ⊃ `Ref` ⊃ `Object`

<pre><code>
        subtype 'Ref'
            => as 'Defined'
            => where {  ref($_) };

        subtype 'Object'
            => as 'Ref'
            => where { blessed($_) }
</code></pre>
##########

型の階層構造
type hierarchy

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

型の強制変換
============
Some Type of Coercion
---------------------

<pre><code>
package Employee;
use Moose;
use Moose::Util::TypeConstraints;
extends qw(Person);

class_type 'Manager';
    
coerce 'Manager' 
    => from 'Str'
    => via { Manager->new( name => $_) };
    
has manager =>  (
    is => 'ro',
    isa => 'Manager',
    required => 1, 
    coerce => 1,
);
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

型の強制変換(つづき)
====================
Some Type of Coercion (cont.)
-----------------------------

<pre><code>
# 型制約のキーワードをインポート(import type constraint keywords)
use Moose::Util::TypeConstraints;


# オブジェクトのサブタイプであるマネージャーを定義(define Manager, a subtype of Object)
class_type "Manager";


# 変換を定義する(define the conversion)
coerce 'Manager' 
    => from 'Str'
    => via { Manager->new( name => $_) };


# アトリビュートごとに有効にする(enable it per attribute)
has manager =>  (
    …
    coerce => 1,
);
</code></pre>

##########

例を細かく見ていくよ
breakdown of the example

クラスの型はMooseのクラスすべてに自動的に用意されます
class types are automatically created for all Moose classes

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

伝統的な委譲
============
Conventional Delegates
----------------------

<pre><code>
package Employee;
use Moose;
extends qw(Person);
    
has manager =>  (
    is => 'ro',
    isa => 'Manager',
    handles => {
        manager_name => 'name',
        coworkers    => 'staff',
    }
);
</code></pre>

* マネージャーは `Employee` のいくつかのメソッドを処理します
* manager `handles` certain methods for `Employee`
    * `$emp->coworkers` == `$emp->manager->staff `

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

伝統的な委譲(つづき)
====================
Conventional Delegates (cont.)
------------------------------

<pre><code>
has phone => (
    ...
    handles => [qw(number extension)],
);
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

伝統的な委譲(つづき)
====================
Conventional Delegates (cont.)
------------------------------

<pre><code>
has phone => (
    isa => "Phone"
    handles => qr/$method_regex/,
);
</code></pre>

* `Phone->meta->compute_all_applicable_methods`にフィルターをかける
* Filters `Phone->meta->compute_all_applicable_methods`

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

伝統的な委譲(つづき)
====================
Conventional Delegates (cont.)
------------------------------

<pre><code>
has phone => (
    ...
    handles => "Dialing", # a role
);
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

伝統的じゃない委譲
================
UnConventional Delegates
------------------------

<pre><code>
package Company;
use Moose;
use MooseX::AttributeHelpers;
   
has employees => (
    metaclass => 'Collection::Array',
    isa => 'ArrayRef[Employees]',
    is => 'rw',
    provides => {
        push  => 'add_employee',
        pop   => 'remove_employee',
        count => 'number_of_employees',
        empty => 'any_employees',
    }
);
</code></pre>
✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メソッド変更のセカイ
====================
Modified Methods
----------------

<pre><code>
before 'employees' => sub { warn 'calling employees' };

after 'employees' => sub { warn 'finished calling employees' };
</code></pre>

*  現在のメソッドが実行される前／された後に実行されます
*  Pre/Post hooks
    * `@_`のコピーを得ます(Get a copy of `@_`)
    * 返り値は無視されます(Return value is ignored)

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メソッド変更のセカイ(つづき)
============================
Modified Methods (cont.)
------------------------

<pre><code>
around 'employees' => sub { 
    my ($next, $self, @args) = @_;
    ...
    my @return = $self->$next(@args);
    ...
    return @return;
};
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メソッド変更のセカイ(つづき)
============================
Modified Methods (cont.)
------------------------

<pre><code>
package Employee;
use Moose;

sub do_work {
    my $self = shift;
    
    $self->punch_in;
    
    inner(); # call subclass here
    
    $self->punch_out;
}
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メソッド変更のセカイ(つづき)
============================
Modified Methods (cont.)
------------------------

<pre><code>
package Employee::Chef;
use Moose;

extends qw(Employee);

augment do_work => sub {
    my $self = shift;
    
    while ( @burgers ) {
        $self->flip_burger(shift @burgers);
    }
}

$chef->do_work; # punch in, flip burgers, punch out
</code></pre>
✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

型についての余談
================
Some Type of Digression
-----------------------

<pre><code>
has employees => (
    is => 'rw',
    isa => 'ArrayRef[Employee]',
);

has shopping_carts => (
    is => 'rw',
    isa => 'ArrayRef[ArrayRef[ShinyBead]]'
);
</code></pre>

##########

型システムの機能についてちょっと説明していくよ
Going to go into features of the type system for a bit

パラメータ付きの型
Parametrized types

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

型についての余談(つづき)
========================
Some Type of Digression (cont.)
-------------------------------

<pre><code>
has language => (
    is => 'rw',
    isa => 'English | Welsh | Scots | Gaelic',
);  

has member => (
    is => 'rw',
    isa => 'Employee | ArrayRef[Employee|Group]',
);
</code></pre>

##########

型の結合
Union types

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

型についての余談(つづき)
========================
Some Type of Digression (cont.)
-------------------------------

<pre><code>
package Foo;
use Moose;
use Moose::Util::TypeConstraints;
use Test::Deep qw(eq_deeply ...);

type 'SomethingTricky' 
    => where {
        eq_deeply( $_, ... );
    };

has 'bar' => (
    is  => 'rw',
    isa => 'SomethingTricky',
);
</code></pre>

##########

Test::Deppのカスタムバリデータ
Test::Deep custom validator

CPANからどんなバリデータでも持ってこられる
Can use any validation from the CPAN

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

パラメータ付きの型の強制変換
============================
Some Parametrized Type of Coercion
----------------------------------

<pre><code>
use Moose::Util::TypeConstraints;   
subtype 'ArrayRef[Employee]' => as 'ArrayRef';

coerce 'ArrayRef[Employee]' 
    => from 'ArrayRef[Str]' 
    => via { [ map { Employee->new( name => $_ ) } @$_ ] };

has staff => (
    is         => 'ro',
    isa        => 'ArrayRef[Employee]',
    lazy       => 1,
    default    => sub { [qw(Bob Alice Tim)] },
    coerce     => 1,
);
</code></pre>

##########

ArrayRef[Str] から ArrayRef[Employee] に強制変換
coerce parametrized ArrayRef[Employee] from ArrayRef[Str]

強制変換は 'default' の返り値にも適用されます
coercions can be applied to 'default' return values

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole 
===========
Role of the Moose
-----------------

* Role は…(A role is like a)
    * JavaのInterfaceみたい
    * mixinみたい
    * …それでいて安全でパワフル(safe, powerful)
* Role は小さくて再利用可能な動作向け(A role is for small reusable behaviors)
    * 多重継承よりよい(better than using a multiple inheritence)

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole(つづき)
===================
Role of the Moose (cont.)
-------------------------

* CPAN にある Role たち(Roles on the CPAN):
    * `MooseX::Storage` - 柔軟なシリアライズ(Flexible serialization)
    * `MooseX::LogDispatch` - `$self->logger->info("something happenned")`
    * `MooseX::Getopt` - コマンドライン引数の処理(`@ARGV` aware constructor)
    * `MooseX::Param` - `CGI.pm` の `param()` メソッドみたいなの(`param` method like `CGI.pm`'s)
    * `MooseX::Clone` - 柔軟な`clone`メソッド(Flexible `clone` method)

##########

再利用可能な小さな動作の例
Some examples of small reusable behaviors

Paramは連携に便利
Param is good for interacting with e.g. CGI::Expand or similar modules

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole(つづき)
===================
Role of the Moose (cont.)
-------------------------

<pre><code>
package Minion;
use Moose;

extends qw(Employee);

with qw(Salaried::Hourly);

package Boss;
use Moose;

extends qw(Employee);

with qw(Salaried::Monthly);

</code></pre>

* `with` はクラスに Role を追加します
* `with` adds roles into your class
    * `Salaried::Hourly`が`Minion`に追加される
    * `Salaried::Hourly` was added to `Minion`

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole(つづき)
===================
Role of the Moose (cont.)
-------------------------

<pre><code>
package Salaried;
use Moose::Role;

requires qw('paycheck_amount');
</code></pre>

* 単なるインターフェース
* Just an interface

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole(つづき)
===================
Role of the Moose (cont.)
-------------------------

<pre><code>
package Salaried::Hourly;
use Moose::Role;

with qw(Salaried);

has hourly_rate => (
    isa => "Num",
    is  => "rw",
    required => 1,
);

has logged_hours => (
    isa => "Num",
    is  => "rw",
    default => 0,
);

sub paycheck_amount {
    my $self = shift;
    
    $self->logged_hours * $self->hourly_rate;
}

</code></pre>

* インターフェースよりイイネ!
* More than an interface

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole(つづき)
===================
Role of the Moose (cont.)
-------------------------

* Javaのインターフェースよりイイネ!
* More than Java Interfaces
    * インターフェースは挙動の'規定'を提供する
    * Interfaces are behavior "contracts"
    * Role は挙動の'実装'も提供できる
    * Roles can also have code

##########
Roleはアトリビュートとメソッドを持てる
roles can have attributes and methods
Roleはインターフェースだけでなく動作を提供するもの
roles provide behavior, not just interface

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole(つづき)
===================
Role of the Moose (cont.)
-------------------------

* Roleの組み込み(Role Composition)
    * 継承ではない(Not inheritence)
    * 喧嘩両成敗(Symmetric)
    * 順序は関係ない(Unordered)

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole(つづき)
===================
Role of the Moose (cont.)
-------------------------

* Roleの組み込み(Role Composition)
    * あいまいさが少ない(Less ambiguity)
    * コンパイル時エラー(Compile time errors)
    * …修正する方法もある(And ways to fix them)

##########
喧嘩両成敗というのは優先順位がないということ。ふたつのRoleが同じものを定義しようとした場合はコンパイル時にエラーになる（直さないといけない）
symmetric composition means no precedence - if two roles try to define the same thing you get a compile time error that needs to be resolved
多重継承の場合はだまって最初のクラスを使うもんだと想定してしまう
multiple inheritence silently assumes you want the first class

Roleは多重継承と違ってコンパイル時にエラーを吐く
roles cause errors at compile time, unlike multiple inheritence

Roleは簡単にエラーを修正する方法も用意している
roles also provide easy ways to fix the errors

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole(つづき)
===================
Role of the Moose (cont.)
-------------------------

<pre><code>
package First;
use Moose::Role;

sub dancing { ... }

package Second;
use Moose::Role

sub dancing { ... }

package Foo;
use Moose;

# KABOOM
with qw(
    First
    Second
);
</code></pre>

##########

衝突
conflicts

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseのRole(つづき)
===================
Role of the Moose (cont.)
-------------------------

<pre><code>
package Ent::Puppy;
use Moose;

with (
    Tree => {
        alias => {
            bark => "tree_bark",
        },
    },
    Dog => {
        alias => {
            bark => "bark_sound",
        }
    },
);

sub bark {
    my $self = shift;
    
    if ( $condition ) {
        $self->tree_bark;
    } else {
        $self->bark_sound;
    }
}
</code></pre>

##########

組み込むときにパラメータをつける
Composition parameters
衝突を解決するのも簡単だし
Easier conflict resolution
よりきめ細かいコントロールができるようになる
Finer grained control

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MOPはキレイ
===========
MOPs Mean Cleanliness
---------------------

* Moose は Class::MOP でつくられてる
* Moose is based on `Class::MOP`
    * Perl5のためのメタオブジェクトプロトコル(Metaobject Protocol for Perl 5)
    * すべてにオブジェクトがつくられる("makes an object for everything")
    
<pre><code>
my $class = $obj->meta; # $objのメタクラス($obj's metaclass)
my $meta = MyApp->meta; # MyAppのメタクラス(MyApp's metaclass)
my $emo  = $obj->meta->meta # メタメタ(even more meta)!

warn  $obj->meta->name;
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

内側からみてみる
================
Looking in From the Inside
--------------------------

<pre><code>
my $metaclass = $self->meta; 

$metaclass->superclasses;

$metaclass->linearized_isa; # すべての先祖クラスを得ます(returns all ancestors)

$metaclass->has_method("foo");

$metaclass->compute_all_applicable_methods; # すべてのメソッド(継承されたものもふくめて)(returns all methods (inherited too))

$metaclass->has_attribute("bar");

# … lots more
</code></pre>
##########

simple introspection

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

内側からみてみる(つづき)
========================
Looking in From the Inside (cont.)
----------------------------------

<pre><code>
Moose::Meta::Class->create( Bar =>
      version      => '0.01',
      superclasses => [ 'Foo' ],
      attributes => [
          Moose::Meta::Attribute->new( bar => ... ),
          Moose::Meta::Attribute->new( baz => ... ),
      ],
      methods => {
          calculate_bar => sub { ... },
          construct_baz => sub { ... }
      }
);
</code></pre>

##########

クラスはプログラム的につくることもできる
Classes can be created programmatically

無名クラスも可
Anonymous classes also possible
✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

内側からみてみる(つづき)
========================
Looking in From the Inside (cont.)
----------------------------------

<pre><code>
has foo => ( is => "rw" );

__PACKAGE__->meta->add_attribute( foo => is => "rw" );
</code></pre>

* Mooseは単なるシュガー(Moose is just sugar)
    * 大変な部分はMOPがしてくれる(The MOP does the hard work)

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メタクラスのタンゴ
==================
The Metaclass Tango
-------------------

* メタクラスはクラスの挙動をコントロールする
* Metaclassses control class behavior

<pre><code>
has employees => (
    metaclass => 'Collection::Array',
    ...
);
</code></pre>

* カスタムアトリビュートメタクラスは
* custom attribute metaclasses
    * アトリビュートがどういう風に動くかを変える
    * change how attributes work
* カスタマイズ可能なパーツたち
* Many customizable parts
    * `Moose::Meta::Class`, `Moose::Meta::Attribute, ``Moose::Meta::Method`, `Moose::Meta::Method::Accessor` `Moose::Meta::Instance`, `Moose::Meta::Role`, `Moose::Meta::TypeConstraint`, …,

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メタフレームを使う
==================
Working in the Meta Frame
-------------------------

* 仕事であったおもろい話(An interesting `$work` story)
* flashを使ったサイト用のCMS(CMS for a flash website)
* コンテンツはXML(Content is in XML)

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メタフレームを使う(つづき)
==========================
Working in the Meta Frame (cont.)
---------------------------------

* Step 1. use Moose
* Step 2. ???
* Step 3. 金(Profit)!

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メタフレームを使う(つづき)
==========================
Working in the Meta Frame (cont.)
---------------------------------

* Step 2.1. XMLスキーマ(schemas) → クラス(classes)
    * 自動変換(Automatic conversion)
        * MOPのおかげで楽勝(MOP makes it easy)
    * 実行時には高レベルオブジェクト(High level objects in runtime)
    * 裏ではXML(XML backed)
        * クライアントのスキーマ(With client's schemas)
        * SAX → Moose
        * Moose → SAX

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メタフレームを使う(つづき)
==========================
Working in the Meta Frame (cont.)
---------------------------------

* Step 2.2. メタ記述(Meta descriptions)
    * メタクラスを拡張(Extend the metaclasses)
    * 追加の情報を埋め込む(Embed additional information)
        * フィールド型(field types)
        * アクセスコントロール(access control)

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

メタフレームを使う(つづき)
==========================
Working in the Meta Frame (cont.)
---------------------------------

* Step 2.3 イントロスペクションかわゆす(Introspection goodness)
    * 汎用Webフロントエンド(Generic web frontend)
    * オブジェクトイントロスペクションベース(Object introspection based)
        * HTMLビュー(view)
        * 編集用のウィジェット(Editing widgets)
    * クリーンで拡張性も高い(Clean, extensible)

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Moose の欠点
============
Drawbacks of Moose
------------------

* ロード時間(Load time)
    * `MooseX::Compile` がアルでよ(`MooseX::Compile` is in the works)
* いくつかの機能が遅い(Some features are slow)
    * でも、あなたがつかったぶんだけだから(but you only pay for what you use)
* hashref じゃないクラスの拡張はトリッキー(Extending non-Hash based classes is tricky).
    * でも可能(but possible): `MooseX::GlobRef::Object`

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseのイイ!とこ
================
Benefits of Moose
-----------------

* 退屈なことを減らせる(Less tedious)
      * 決まり文句を書かなくていい(ditch that boilerplate):
          * アトリビュートのストレージ/アクセサ(attribute storage/access)
          * コンストラクタ(construction)
          * デストラクタ(destruction)
          * 引数検査(verification)
          * …
      * 繰り返しを減らせる(less repetition)
      * typo を減らせる(fewer typos)

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseのイイ!とこ(つづき)
========================
Benefits of Moose (cont.)
-------------------------

* みじかい(Shorter)
      * declarative == 情報がおおく、タイプ数がすくない(more info, less typing)
      * no RSI ;-)
      * コードがすくなきゃバグもすくなかろう(less code means fewer bugs)

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseのイイ!とこ(つづき)
========================
Benefits of Moose (cont.)
-------------------------

* テストがすくなくていい(Less testing)
      * Moose はよくテストされておる
      * Moose is well tested
          * アクセサやら挙動やらをチェックせんでもよろし
          * no need to check accessor behavior, etc
      * あなたのコードの目的にフォーカスできます!
      * focus on your code's purpose
          * きちんと「まとめて」おかなくてもいいよ
          * not that it is "assembled" correctly
          * http://c2.com/cgi/wiki?IntentionNotAlgorithm

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseのイイ!とこ(つづき)
========================
Benefits of Moose (cont.)
-------------------------

* 読みやすい(More readable)
      * 宣言的なスタイルだからそのまま文書になっている
      * declarative style is self documenting
      * やりたいことを書け。関係ないOOのしかけとかはあまり書かなくてもいい
      * Code your intentions, not and OO mechanics less

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseのイイ!とこ(つづき)
========================
Benefits of Moose (cont.)
-------------------------

* Meta object protocol
    * Perl の OO を綺麗にあつかえます
    * Cleans up all levels of Perl's OO
    * イントロスペクションできます
    * Provides introspection
    * パワフルな抽象化
    * Enables powerful abstractions

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Mooseのイイ!とこ(つづき)
========================
Benefits of Moose (cont.)
-------------------------

* 今年の流行だよ
* It's the new black
    * イカした連中はみんな#mooseにきている
    * All the cool kids hang out on #moose
    * かっこよさげなバズワード
    * Smart sounding buzzwords
    * 2007年にはRubyがそうだったね
    * Ruby is so 2007

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

おまけ
======
Bonus Material
--------------

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Autobox
=======

<pre><code>
package Units::Bytes;
use Moose::Role;
use Moose::Autobox;

sub bytes     { $_[0]                   }    
sub kilobytes { $_[0] * 1024            }
sub megabytes { $_[0] * 1024->kilobytes }
sub gigabytes { $_[0] * 1024->megabytes }
sub terabytes { $_[0] * 1024->gigabytes }

Moose::Autobox->mixin_additional_role(SCALAR => 'Units::Bytes');
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Autobox (つづき)
================
Autobox (cont.)
---------------

<pre><code>
use Units::Bytes;
use Moose::Autobox;

is(5->bytes,     5,             '... got 5 bytes');
is(5->kilobytes, 5120,          '... got 5 kilobytes');
is(2->megabytes, 2097152,       '... got 2 megabytes');
is(1->gigabytes, 1073741824,    '... got 1 gigabyte');
is(2->terabytes, 2199023255552, '... got 2 terabyte');
</code></pre>

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

perl -Moose
===========

* Moose なワンライナーには `oose.pm` があるでよ
* Moose One Liners with `oose.pm`

<pre><code>
perl -Moose -e'has foo => (is=>q[rw]); Class->new(foo=>1)'
</code></pre>

* なんかためしたいときなどに
* Useful for testing if something works
* IRC での会話には欠かせませんな!
* Nice for IRC

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

MooseX::POE
===========

<pre><code>
package Counter;
use MooseX::POE;

has count => (
    isa     => 'Int',
    is      => 'rw',
);

sub START {
    my ($self) = @_;
    $self->yield('increment');
}

event increment => sub {
    my ($self) = @_;
    warn "Count is now " . $self->count;
    $self->count( $self->count + 1 );
    $self->yield('increment') unless $self->count > 3;
};

Counter->new( count => 0 );
POE::Kernel->run();
</code></pre>

* POE のコンポーネントを簡単にかけます
* POE components made easy
* それぞれのオブジェクトが POE::Session をもってます
* Every object has a POE::Session
* `event` がオブジェクトのステートを宣言します
* `event` declares object states

✂------✂------✂------✂------✂------✂------✂------✂------✂------✂------

Fin
===

* Slides written by:
    * Chris Prather
    * Stevan Little
    * Robert Boone

* Slides deleted by:
    * Yuval Kogman

* Slides translated by:
    * tokuhirom
