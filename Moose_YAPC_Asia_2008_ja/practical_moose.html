<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Moose</title>
<!-- metadata -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="generator" content="TextMate/S5" />
<meta name="version" content="S5 1.2a2" />
<meta name="presdate" content="2008" />
<meta name="author" content="Yuval Kogman" />
<meta name="company" content="" />
<!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="visible" />
<!-- style sheet links -->
<link rel="stylesheet" href="./ui/moose/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="./ui/moose/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="./ui/moose/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="./ui/moose/opera.css" type="text/css" media="projection" id="operaFix" />
<!-- embedded styles -->
<style type="text/css" media="all">
.imgcon {width: 525px; margin: 0 auto; padding: 0; text-align: center;}
#anim {width: 270px; height: 320px; position: relative; margin-top: 0.5em;}
#anim img {position: absolute; top: 42px; left: 24px;}
img#me01 {top: 0; left: 0;}
img#me02 {left: 23px;}
img#me04 {top: 44px;}
img#me05 {top: 43px;left: 36px;}
</style>
<!-- S5 JS -->
<script src="./ui/moose/slides.js" type="text/javascript"></script>
</head>
<body>

<div class="layout">
<div id="controls"><!-- DO NOT EDIT --></div>
<div id="currentSlide"><!-- DO NOT EDIT --></div>
<div id="header"></div>
<div id="footer">
<h1>YAPC::Asia::2008</h1>
<h2>Moose</h2>
</div>
<div class="topleft"></div>
<div class="topright"></div>
<div class="bottomleft"></div>
<div class="bottomright"></div>
</div>

<div class="presentation">

<div class="slide">
<h1>Moose</h1>
<h2></h2>
<h3>Yuval Kogman</h3>
<h4></h4>
</div>


<div class="slide">
<h1>Moose はなにではないか</h1>

<h2>Moose Is Not</h2>

<ul>
<li>実験やプロトタイプ (experimental)</li>
<li>おもちゃ (toy)</li>
<li>もう一つのアクセサビルダー (accessor builder)</li>
<li>ソースフィルタ (source filter)</li>
<li>黒魔術 (black magic)</li>
<li>Perl 6 in Perl 5</li>
</ul>

</div>

<div class="slide">
<h1>Mooseとはなにか</h1>

<h2>Moose Is</h2>

<ul>
<li><p>Perlのための完全にモダンなオブジェクトフレームワーク</p></li>
<li><p>A complete modern object framework for Perl</p></li>
</ul>

</div>

<div class="slide">
<h1>Mooseとはなにか</h1>

<h2>Moose Is</h2>

<ul>
<li>Class::MOPのためのシンタックスシュガー (Syntactic sugar)</li>
<li>祖先たち (ancestry)
<ul>
<li>CLOS (Common Lisp Object System)</li>
<li>Smalltalk</li>
<li>Alces latifrons</li>
<li>Perl 6</li>
<li>…</li>
</ul></li>
<li>安定していて、お仕事にもつかえます (Stable &amp; Production ready)</li>
</ul>

</div>

<div class="slide">
<h1>シンプルな例</h1>

<h2>A Simple Example</h2>

<pre><code>
package Person;

use strict;
use warnings;

sub new {
    my ($class) = @_;

    return bless {
        name => '',
        age  => undef,
    }, $class;
}

sub name {
    my ($self, $name) = @_;
    $self->{'name'} = $name if $name;
    return $self->{'name'};
}

sub age {
    my ($self, $age) = @_;
    $self->{'age'} = $age if $age;
    return $self->{'age'}; 
}

1;
</code></pre>

</div>

<div class="slide">
<h1>シンプルなMooseの例</h1>

<h2>A Simple Moose Example</h2>

<pre><code>
package Person;
use Moose;

has name => (is => 'rw');
has age  => (is => 'rw');

1;
</code></pre>

</div>

<div class="slide">
<h1>シンプルなMooseの例(つづき)</h1>

<h2>A Simple Moose Example (cont.)</h2>

<ul>
<li><code>use Moose;</code> 
<ul>
<li>キーワードをインポート (imports keywords)</li>
<li><code>use strict; use warnings;</code></li>
<li><code>@ISA = qw(Moose::Object) unless @ISA</code></li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>シンプルなMooseの例(つづき)</h1>

<h2>A Simple Moose Example (cont.)</h2>

<ul>
<li><p><code>has</code> はアトリビュートを定義する (declares attibutes)</p>

<ul>
<li>アクセサを生成 (generates accessors)</li>
<li><code>is =&gt; 'rw'</code> → 読み書き両用アクセサ</li>
<li><code>is =&gt; 'ro'</code> → 読み込み専用アクセサ</li>
<li><code>writer</code>, <code>reader</code></li>
</ul></li>
<li><p><code>new</code> は <code>Moose::Object</code> から継承する</p></li>
</ul>

<div class="notes">
<p>今度はアトリビュートの機能を説明していくよ
Now we&#8217;re going to discuss more features of the attributes</p>
</div>
</div>

<div class="slide">
<h1>Mooseの例のバリエーション</h1>

<h2>Variations on a Moose Example</h2>

<pre><code>
package Person;
use Moose;

has name => (
    is => 'rw', 
    isa => 'Str'
    default => 'Bob'
);

has staff => (
    is      => 'ro',
    isa     => 'ArrayRef',
    lazy    => 1,
    default => sub { [qw(Bob Alice Tim)] },
);
</code></pre>

<div class="notes">
<p>default と isa が追加されてます
Adds default, isa</p>
</div>
</div>

<div class="slide">
<h1>Mooseの例のバリエーション(つづき)</h1>

<h2>Variations on a Moose Example (cont.)</h2>

<ul>
<li><p><code>default</code> は</p>

<ul>
<li>コードリファレンス (coderef)</li>
<li>またはリファレンス以外 (数値, 文字列) (nonref)</li>
<li><code>new</code> にパラメータがわたされなかったときに使われる</li>
</ul></li>
<li><p><code>lazy</code> は <code>default</code> を遅延させる</p>

<ul>
<li>最初に <code>$object-&gt;staff</code> が使われたときに呼ばれる (generates)</li>
<li><code>new</code> の中ではなく (no param)</li>
</ul></li>
</ul>

<div class="notes">
<p>デフォルトの話
discusses default</p>

<p>リファレンスでないと想定外の共有がむずかしくなる
non refs make accidental sharing hard</p>
</div>
</div>

<div class="slide">
<h1>Mooseの例のバリエーション(つづき)</h1>

<h2>Variations on a Moose Example (cont.)</h2>

<ul>
<li><code>isa</code> は型を規定する (specifies type)
<ul>
<li><code>Moose::Util::TypeConstraints</code>
<ul>
<li><code>Any, Item, Bool, Undef, Defined, Value, Num, Int, Str, Ref, ScalarRef, ArrayRef, HashRef, CodeRef, RegexpRef, GlobRef, FileHandle, Object, and Role</code></li>
</ul></li>
<li>型は存在する必要はありません (don&#8217;t need to exist)</li>
</ul></li>
</ul>

<pre><code>
            has 'date' => (isa => 'DateTime'); # DWIM
</code></pre>

<div class="notes">
<p>isa, 型の制約
isa, type constraints</p>
</div>
</div>

<div class="slide">
<h1>型</h1>

<h2>Typical Family</h2>

<ul>
<li>型は階層構造をもっている (types have a hierarchy)
<ul>
<li><code>Item</code> ⊃ <code>Defined</code> ⊃ <code>Ref</code> ⊃ <code>Object</code></li>
</ul></li>
</ul>

<pre><code>
        subtype 'Ref'
            => as 'Defined'
            => where {  ref($_) };

        subtype 'Object'
            => as 'Ref'
            => where { blessed($_) }
</code></pre>

<div class="notes">
<p>型の階層構造
type hierarchy</p>
</div>
</div>

<div class="slide">
<h1>型の強制変換</h1>

<h2>Some Type of Coercion</h2>

<pre><code>
package Employee;
use Moose;
use Moose::Util::TypeConstraints;
extends qw(Person);

class_type 'Manager';

coerce 'Manager' 
    => from 'Str'
    => via { Manager->new( name => $_) };

has manager =>  (
    is => 'ro',
    isa => 'Manager',
    required => 1, 
    coerce => 1,
);
</code></pre>

</div>

<div class="slide">
<h1>型の強制変換(つづき)</h1>

<h2>Some Type of Coercion (cont.)</h2>

<pre><code>
# 型制約のキーワードをインポート(import type constraint keywords)
use Moose::Util::TypeConstraints;


# オブジェクトのサブタイプであるマネージャーを定義(define Manager, a subtype of Object)
class_type "Manager";


# 変換を定義する(define the conversion)
coerce 'Manager' 
    => from 'Str'
    => via { Manager->new( name => $_) };


# アトリビュートごとに有効にする(enable it per attribute)
has manager =>  (
    …
    coerce => 1,
);
</code></pre>

<div class="notes">
<p>例を細かく見ていくよ
breakdown of the example</p>

<p>クラスの型はMooseのクラスすべてに自動的に用意されます
class types are automatically created for all Moose classes</p>
</div>
</div>

<div class="slide">
<h1>伝統的な委譲</h1>

<h2>Conventional Delegates</h2>

<pre><code>
package Employee;
use Moose;
extends qw(Person);

has manager =>  (
    is => 'ro',
    isa => 'Manager',
    handles => {
        manager_name => 'name',
        coworkers    => 'staff',
    }
);
</code></pre>

<ul>
<li>マネージャーは <code>Employee</code> のいくつかのメソッドを処理します</li>
<li>manager <code>handles</code> certain methods for <code>Employee</code>
<ul>
<li><code>$emp-&gt;coworkers</code> == <code>$emp-&gt;manager-&gt;staff</code></li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>伝統的な委譲(つづき)</h1>

<h2>Conventional Delegates (cont.)</h2>

<pre><code>
has phone => (
    ...
    handles => [qw(number extension)],
);
</code></pre>

</div>

<div class="slide">
<h1>伝統的な委譲(つづき)</h1>

<h2>Conventional Delegates (cont.)</h2>

<pre><code>
has phone => (
    isa => "Phone"
    handles => qr/$method_regex/,
);
</code></pre>

<ul>
<li><code>Phone-&gt;meta-&gt;compute_all_applicable_methods</code>にフィルターをかける</li>
<li>Filters <code>Phone-&gt;meta-&gt;compute_all_applicable_methods</code></li>
</ul>

</div>

<div class="slide">
<h1>伝統的な委譲(つづき)</h1>

<h2>Conventional Delegates (cont.)</h2>

<pre><code>
has phone => (
    ...
    handles => "Dialing", # a role
);
</code></pre>

</div>

<div class="slide">
<h1>伝統的じゃない委譲</h1>

<h2>UnConventional Delegates</h2>

<pre><code>
package Company;
use Moose;
use MooseX::AttributeHelpers;

has employees => (
    metaclass => 'Collection::Array',
    isa => 'ArrayRef[Employees]',
    is => 'rw',
    provides => {
        push  => 'add_employee',
        pop   => 'remove_employee',
        count => 'number_of_employees',
        empty => 'any_employees',
    }
);
</code></pre>

</div>

<div class="slide">
<h1>メソッド変更のセカイ</h1>

<h2>Modified Methods</h2>

<pre><code>
before 'employees' => sub { warn 'calling employees' };

after 'employees' => sub { warn 'finished calling employees' };
</code></pre>

<ul>
<li>現在のメソッドが実行される前／された後に実行されます</li>
<li>Pre/Post hooks
<ul>
<li><code>@_</code>のコピーを得ます(Get a copy of <code>@_</code>)</li>
<li>返り値は無視されます(Return value is ignored)</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>メソッド変更のセカイ(つづき)</h1>

<h2>Modified Methods (cont.)</h2>

<pre><code>
around 'employees' => sub { 
    my ($next, $self, @args) = @_;
    ...
    my @return = $self->$next(@args);
    ...
    return @return;
};
</code></pre>

</div>

<div class="slide">
<h1>メソッド変更のセカイ(つづき)</h1>

<h2>Modified Methods (cont.)</h2>

<pre><code>
package Employee;
use Moose;

sub do_work {
    my $self = shift;

    $self->punch_in;

    inner(); # call subclass here

    $self->punch_out;
}
</code></pre>

</div>

<div class="slide">
<h1>メソッド変更のセカイ(つづき)</h1>

<h2>Modified Methods (cont.)</h2>

<pre><code>
package Employee::Chef;
use Moose;

extends qw(Employee);

augment do_work => sub {
    my $self = shift;

    while ( @burgers ) {
        $self->flip_burger(shift @burgers);
    }
}

$chef->do_work; # punch in, flip burgers, punch out
</code></pre>

</div>

<div class="slide">
<h1>型についての余談</h1>

<h2>Some Type of Digression</h2>

<pre><code>
has employees => (
    is => 'rw',
    isa => 'ArrayRef[Employee]',
);

has shopping_carts => (
    is => 'rw',
    isa => 'ArrayRef[ArrayRef[ShinyBead]]'
);
</code></pre>

<div class="notes">
<p>型システムの機能についてちょっと説明していくよ
Going to go into features of the type system for a bit</p>

<p>パラメータ付きの型
Parametrized types</p>
</div>
</div>

<div class="slide">
<h1>型についての余談(つづき)</h1>

<h2>Some Type of Digression (cont.)</h2>

<pre><code>
has language => (
    is => 'rw',
    isa => 'English | Welsh | Scots | Gaelic',
);  

has member => (
    is => 'rw',
    isa => 'Employee | ArrayRef[Employee|Group]',
);
</code></pre>

<div class="notes">
<p>型の結合
Union types</p>
</div>
</div>

<div class="slide">
<h1>型についての余談(つづき)</h1>

<h2>Some Type of Digression (cont.)</h2>

<pre><code>
package Foo;
use Moose;
use Moose::Util::TypeConstraints;
use Test::Deep qw(eq_deeply ...);

type 'SomethingTricky' 
    => where {
        eq_deeply( $_, ... );
    };

has 'bar' => (
    is  => 'rw',
    isa => 'SomethingTricky',
);
</code></pre>

<div class="notes">
<p>Test::Deppのカスタムバリデータ
Test::Deep custom validator</p>

<p>CPANからどんなバリデータでも持ってこられる
Can use any validation from the CPAN</p>
</div>
</div>

<div class="slide">
<h1>パラメータ付きの型の強制変換</h1>

<h2>Some Parametrized Type of Coercion</h2>

<pre><code>
use Moose::Util::TypeConstraints;   
subtype 'ArrayRef[Employee]' => as 'ArrayRef';

coerce 'ArrayRef[Employee]' 
    => from 'ArrayRef[Str]' 
    => via { [ map { Employee->new( name => $_ ) } @$_ ] };

has staff => (
    is         => 'ro',
    isa        => 'ArrayRef[Employee]',
    lazy       => 1,
    default    => sub { [qw(Bob Alice Tim)] },
    coerce     => 1,
);
</code></pre>

<div class="notes">
<p>ArrayRef[Str] から ArrayRef[Employee] に強制変換
coerce parametrized ArrayRef[Employee] from ArrayRef[Str]</p>

<p>強制変換は &#8216;default&#8217; の返り値にも適用されます
coercions can be applied to &#8216;default&#8217; return values</p>
</div>
</div>

<div class="slide">
<h1>MooseのRole </h1>

<h2>Role of the Moose</h2>

<ul>
<li>Role は…(A role is like a)
<ul>
<li>JavaのInterfaceみたい</li>
<li>mixinみたい</li>
<li>…それでいて安全でパワフル(safe, powerful)</li>
</ul></li>
<li>Role は小さくて再利用可能な動作向け(A role is for small reusable behaviors)
<ul>
<li>多重継承よりよい(better than using a multiple inheritence)</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>MooseのRole(つづき)</h1>

<h2>Role of the Moose (cont.)</h2>

<ul>
<li>CPAN にある Role たち(Roles on the CPAN):
<ul>
<li><code>MooseX::Storage</code> - 柔軟なシリアライズ(Flexible serialization)</li>
<li><code>MooseX::LogDispatch</code> - <code>$self-&gt;logger-&gt;info("something happenned")</code></li>
<li><code>MooseX::Getopt</code> - コマンドライン引数の処理(<code>@ARGV</code> aware constructor)</li>
<li><code>MooseX::Param</code> - <code>CGI.pm</code> の <code>param()</code> メソッドみたいなの(<code>param</code> method like <code>CGI.pm</code>&#8217;s)</li>
<li><code>MooseX::Clone</code> - 柔軟な<code>clone</code>メソッド(Flexible <code>clone</code> method)</li>
</ul></li>
</ul>

<div class="notes">
<p>再利用可能な小さな動作の例
Some examples of small reusable behaviors</p>

<p>Paramは連携に便利
Param is good for interacting with e.g. CGI::Expand or similar modules</p>
</div>
</div>

<div class="slide">
<h1>MooseのRole(つづき)</h1>

<h2>Role of the Moose (cont.)</h2>

<pre><code>
package Minion;
use Moose;

extends qw(Employee);

with qw(Salaried::Hourly);

package Boss;
use Moose;

extends qw(Employee);

with qw(Salaried::Monthly);

</code></pre>

<ul>
<li><code>with</code> はクラスに Role を追加します</li>
<li><code>with</code> adds roles into your class
<ul>
<li><code>Salaried::Hourly</code>が<code>Minion</code>に追加される</li>
<li><code>Salaried::Hourly</code> was added to <code>Minion</code></li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>MooseのRole(つづき)</h1>

<h2>Role of the Moose (cont.)</h2>

<pre><code>
package Salaried;
use Moose::Role;

requires qw('paycheck_amount');
</code></pre>

<ul>
<li>単なるインターフェース</li>
<li>Just an interface</li>
</ul>

</div>

<div class="slide">
<h1>MooseのRole(つづき)</h1>

<h2>Role of the Moose (cont.)</h2>

<pre><code>
package Salaried::Hourly;
use Moose::Role;

with qw(Salaried);

has hourly_rate => (
    isa => "Num",
    is  => "rw",
    required => 1,
);

has logged_hours => (
    isa => "Num",
    is  => "rw",
    default => 0,
);

sub paycheck_amount {
    my $self = shift;

    $self->logged_hours * $self->hourly_rate;
}

</code></pre>

<ul>
<li>インターフェースよりイイネ!</li>
<li>More than an interface</li>
</ul>

</div>

<div class="slide">
<h1>MooseのRole(つづき)</h1>

<h2>Role of the Moose (cont.)</h2>

<ul>
<li>Javaのインターフェースよりイイネ!</li>
<li>More than Java Interfaces
<ul>
<li>インターフェースは挙動の&#8217;規定&#8217;を提供する</li>
<li>Interfaces are behavior &#8220;contracts&#8221;</li>
<li>Role は挙動の&#8217;実装&#8217;も提供できる</li>
<li>Roles can also have code</li>
</ul></li>
</ul>

<div class="notes">
<p>Roleはアトリビュートとメソッドを持てる
roles can have attributes and methods
Roleはインターフェースだけでなく動作を提供するもの
roles provide behavior, not just interface</p>
</div>
</div>

<div class="slide">
<h1>MooseのRole(つづき)</h1>

<h2>Role of the Moose (cont.)</h2>

<ul>
<li>Roleの組み込み(Role Composition)
<ul>
<li>継承ではない(Not inheritence)</li>
<li>喧嘩両成敗(Symmetric)</li>
<li>順序は関係ない(Unordered)</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>MooseのRole(つづき)</h1>

<h2>Role of the Moose (cont.)</h2>

<ul>
<li>Roleの組み込み(Role Composition)
<ul>
<li>あいまいさが少ない(Less ambiguity)</li>
<li>コンパイル時エラー(Compile time errors)</li>
<li>…修正する方法もある(And ways to fix them)</li>
</ul></li>
</ul>

<div class="notes">
<p>喧嘩両成敗というのは優先順位がないということ。ふたつのRoleが同じものを定義しようとした場合はコンパイル時にエラーになる（直さないといけない）
symmetric composition means no precedence - if two roles try to define the same thing you get a compile time error that needs to be resolved
多重継承の場合はだまって最初のクラスを使うもんだと想定してしまう
multiple inheritence silently assumes you want the first class</p>

<p>Roleは多重継承と違ってコンパイル時にエラーを吐く
roles cause errors at compile time, unlike multiple inheritence</p>

<p>Roleは簡単にエラーを修正する方法も用意している
roles also provide easy ways to fix the errors</p>
</div>
</div>

<div class="slide">
<h1>MooseのRole(つづき)</h1>

<h2>Role of the Moose (cont.)</h2>

<pre><code>
package First;
use Moose::Role;

sub dancing { ... }

package Second;
use Moose::Role

sub dancing { ... }

package Foo;
use Moose;

# KABOOM
with qw(
    First
    Second
);
</code></pre>

<div class="notes">
<p>衝突
conflicts</p>
</div>
</div>

<div class="slide">
<h1>MooseのRole(つづき)</h1>

<h2>Role of the Moose (cont.)</h2>

<pre><code>
package Ent::Puppy;
use Moose;

with (
    Tree => {
        alias => {
            bark => "tree_bark",
        },
    },
    Dog => {
        alias => {
            bark => "bark_sound",
        }
    },
);

sub bark {
    my $self = shift;

    if ( $condition ) {
        $self->tree_bark;
    } else {
        $self->bark_sound;
    }
}
</code></pre>

<div class="notes">
<p>組み込むときにパラメータをつける
Composition parameters
衝突を解決するのも簡単だし
Easier conflict resolution
よりきめ細かいコントロールができるようになる
Finer grained control</p>
</div>
</div>

<div class="slide">
<h1>MOPはキレイ</h1>

<h2>MOPs Mean Cleanliness</h2>

<ul>
<li>Moose は Class::MOP でつくられてる</li>
<li>Moose is based on <code>Class::MOP</code>
<ul>
<li>Perl5のためのメタオブジェクトプロトコル(Metaobject Protocol for Perl 5)</li>
<li>すべてにオブジェクトがつくられる(&#8220;makes an object for everything&#8221;)</li>
</ul></li>
</ul>

<pre><code>
my $class = $obj->meta; # $objのメタクラス($obj's metaclass)
my $meta = MyApp->meta; # MyAppのメタクラス(MyApp's metaclass)
my $emo  = $obj->meta->meta # メタメタ(even more meta)!

warn  $obj->meta->name;
</code></pre>

</div>

<div class="slide">
<h1>内側からみてみる</h1>

<h2>Looking in From the Inside</h2>

<pre><code>
my $metaclass = $self->meta; 

$metaclass->superclasses;

$metaclass->linearized_isa; # すべての先祖クラスを得ます(returns all ancestors)

$metaclass->has_method("foo");

$metaclass->compute_all_applicable_methods; # すべてのメソッド(継承されたものもふくめて)(returns all methods (inherited too))

$metaclass->has_attribute("bar");

# … lots more
</code></pre>

<div class="notes">
<p>simple introspection</p>
</div>
</div>

<div class="slide">
<h1>内側からみてみる(つづき)</h1>

<h2>Looking in From the Inside (cont.)</h2>

<pre><code>
Moose::Meta::Class->create( Bar =>
      version      => '0.01',
      superclasses => [ 'Foo' ],
      attributes => [
          Moose::Meta::Attribute->new( bar => ... ),
          Moose::Meta::Attribute->new( baz => ... ),
      ],
      methods => {
          calculate_bar => sub { ... },
          construct_baz => sub { ... }
      }
);
</code></pre>

<div class="notes">
<p>クラスはプログラム的につくることもできる
Classes can be created programmatically</p>

<p>無名クラスも可
Anonymous classes also possible</p>
</div>
</div>

<div class="slide">
<h1>内側からみてみる(つづき)</h1>

<h2>Looking in From the Inside (cont.)</h2>

<pre><code>
has foo => ( is => "rw" );

__PACKAGE__->meta->add_attribute( foo => is => "rw" );
</code></pre>

<ul>
<li>Mooseは単なるシュガー(Moose is just sugar)
<ul>
<li>大変な部分はMOPがしてくれる(The MOP does the hard work)</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>メタクラスのタンゴ</h1>

<h2>The Metaclass Tango</h2>

<ul>
<li>メタクラスはクラスの挙動をコントロールする</li>
<li>Metaclassses control class behavior</li>
</ul>

<pre><code>
has employees => (
    metaclass => 'Collection::Array',
    ...
);
</code></pre>

<ul>
<li>カスタムアトリビュートメタクラスは</li>
<li>custom attribute metaclasses
<ul>
<li>アトリビュートがどういう風に動くかを変える</li>
<li>change how attributes work</li>
</ul></li>
<li>カスタマイズ可能なパーツたち</li>
<li>Many customizable parts
<ul>
<li><code>Moose::Meta::Class</code>, <code>Moose::Meta::Attribute,</code><code>Moose::Meta::Method</code>, <code>Moose::Meta::Method::Accessor</code> <code>Moose::Meta::Instance</code>, <code>Moose::Meta::Role</code>, <code>Moose::Meta::TypeConstraint</code>, …,</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>メタフレームを使う</h1>

<h2>Working in the Meta Frame</h2>

<ul>
<li>仕事であったおもろい話(An interesting <code>$work</code> story)</li>
<li>flashを使ったサイト用のCMS(CMS for a flash website)</li>
<li>コンテンツはXML(Content is in XML)</li>
</ul>

</div>

<div class="slide">
<h1>メタフレームを使う(つづき)</h1>

<h2>Working in the Meta Frame (cont.)</h2>

<ul>
<li>Step 1. use Moose</li>
<li>Step 2. ???</li>
<li>Step 3. 金(Profit)!</li>
</ul>

</div>

<div class="slide">
<h1>メタフレームを使う(つづき)</h1>

<h2>Working in the Meta Frame (cont.)</h2>

<ul>
<li>Step 2.1. XMLスキーマ(schemas) → クラス(classes)
<ul>
<li>自動変換(Automatic conversion)
<ul>
<li>MOPのおかげで楽勝(MOP makes it easy)</li>
</ul></li>
<li>実行時には高レベルオブジェクト(High level objects in runtime)</li>
<li>裏ではXML(XML backed)
<ul>
<li>クライアントのスキーマ(With client&#8217;s schemas)</li>
<li>SAX → Moose</li>
<li>Moose → SAX</li>
</ul></li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>メタフレームを使う(つづき)</h1>

<h2>Working in the Meta Frame (cont.)</h2>

<ul>
<li>Step 2.2. メタ記述(Meta descriptions)
<ul>
<li>メタクラスを拡張(Extend the metaclasses)</li>
<li>追加の情報を埋め込む(Embed additional information)
<ul>
<li>フィールド型(field types)</li>
<li>アクセスコントロール(access control)</li>
</ul></li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>メタフレームを使う(つづき)</h1>

<h2>Working in the Meta Frame (cont.)</h2>

<ul>
<li>Step 2.3 イントロスペクションかわゆす(Introspection goodness)
<ul>
<li>汎用Webフロントエンド(Generic web frontend)</li>
<li>オブジェクトイントロスペクションベース(Object introspection based)
<ul>
<li>HTMLビュー(view)</li>
<li>編集用のウィジェット(Editing widgets)</li>
</ul></li>
<li>クリーンで拡張性も高い(Clean, extensible)</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>Moose の欠点</h1>

<h2>Drawbacks of Moose</h2>

<ul>
<li>ロード時間(Load time)
<ul>
<li><code>MooseX::Compile</code> がアルでよ(<code>MooseX::Compile</code> is in the works)</li>
</ul></li>
<li>いくつかの機能が遅い(Some features are slow)
<ul>
<li>でも、あなたがつかったぶんだけだから(but you only pay for what you use)</li>
</ul></li>
<li>hashref じゃないクラスの拡張はトリッキー(Extending non-Hash based classes is tricky).
<ul>
<li>でも可能(but possible): <code>MooseX::GlobRef::Object</code></li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>Mooseのイイ!とこ</h1>

<h2>Benefits of Moose</h2>

<ul>
<li>退屈なことを減らせる(Less tedious)
<ul>
<li>決まり文句を書かなくていい(ditch that boilerplate):
<ul>
<li>アトリビュートのストレージ/アクセサ(attribute storage/access)</li>
<li>コンストラクタ(construction)</li>
<li>デストラクタ(destruction)</li>
<li>引数検査(verification)</li>
<li>…</li>
</ul></li>
<li>繰り返しを減らせる(less repetition)</li>
<li>typo を減らせる(fewer typos)</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>Mooseのイイ!とこ(つづき)</h1>

<h2>Benefits of Moose (cont.)</h2>

<ul>
<li>みじかい(Shorter)
<ul>
<li>declarative == 情報がおおく、タイプ数がすくない(more info, less typing)</li>
<li>no RSI ;-)</li>
<li>コードがすくなきゃバグもすくなかろう(less code means fewer bugs)</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>Mooseのイイ!とこ(つづき)</h1>

<h2>Benefits of Moose (cont.)</h2>

<ul>
<li>テストがすくなくていい(Less testing)
<ul>
<li>Moose はよくテストされておる</li>
<li>Moose is well tested
<ul>
<li>アクセサやら挙動やらをチェックせんでもよろし</li>
<li>no need to check accessor behavior, etc</li>
</ul></li>
<li>あなたのコードの目的にフォーカスできます!</li>
<li>focus on your code&#8217;s purpose
<ul>
<li>きちんと「まとめて」おかなくてもいいよ</li>
<li>not that it is &#8220;assembled&#8221; correctly</li>
<li>http://c2.com/cgi/wiki?IntentionNotAlgorithm</li>
</ul></li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>Mooseのイイ!とこ(つづき)</h1>

<h2>Benefits of Moose (cont.)</h2>

<ul>
<li>読みやすい(More readable)
<ul>
<li>宣言的なスタイルだからそのまま文書になっている</li>
<li>declarative style is self documenting</li>
<li>やりたいことを書け。関係ないOOのしかけとかはあまり書かなくてもいい</li>
<li>Code your intentions, not and OO mechanics less</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>Mooseのイイ!とこ(つづき)</h1>

<h2>Benefits of Moose (cont.)</h2>

<ul>
<li>Meta object protocol
<ul>
<li>Perl の OO を綺麗にあつかえます</li>
<li>Cleans up all levels of Perl&#8217;s OO</li>
<li>イントロスペクションできます</li>
<li>Provides introspection</li>
<li>パワフルな抽象化</li>
<li>Enables powerful abstractions</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>Mooseのイイ!とこ(つづき)</h1>

<h2>Benefits of Moose (cont.)</h2>

<ul>
<li>今年の流行だよ</li>
<li>It&#8217;s the new black
<ul>
<li>イカした連中はみんな#mooseにきている</li>
<li>All the cool kids hang out on #moose</li>
<li>かっこよさげなバズワード</li>
<li>Smart sounding buzzwords</li>
<li>2007年にはRubyがそうだったね</li>
<li>Ruby is so 2007</li>
</ul></li>
</ul>

</div>

<div class="slide">
<h1>おまけ</h1>

<h2>Bonus Material</h2>

</div>

<div class="slide">
<h1>Autobox</h1>

<pre><code>
package Units::Bytes;
use Moose::Role;
use Moose::Autobox;

sub bytes     { $_[0]                   }    
sub kilobytes { $_[0] * 1024            }
sub megabytes { $_[0] * 1024->kilobytes }
sub gigabytes { $_[0] * 1024->megabytes }
sub terabytes { $_[0] * 1024->gigabytes }

Moose::Autobox->mixin_additional_role(SCALAR => 'Units::Bytes');
</code></pre>

</div>

<div class="slide">
<h1>Autobox (つづき)</h1>

<h2>Autobox (cont.)</h2>

<pre><code>
use Units::Bytes;
use Moose::Autobox;

is(5->bytes,     5,             '... got 5 bytes');
is(5->kilobytes, 5120,          '... got 5 kilobytes');
is(2->megabytes, 2097152,       '... got 2 megabytes');
is(1->gigabytes, 1073741824,    '... got 1 gigabyte');
is(2->terabytes, 2199023255552, '... got 2 terabyte');
</code></pre>

</div>

<div class="slide">
<h1>perl -Moose</h1>

<ul>
<li>Moose なワンライナーには <code>oose.pm</code> があるでよ</li>
<li>Moose One Liners with <code>oose.pm</code></li>
</ul>

<pre><code>
perl -Moose -e'has foo => (is=>q[rw]); Class->new(foo=>1)'
</code></pre>

<ul>
<li>なんかためしたいときなどに</li>
<li>Useful for testing if something works</li>
<li>IRC での会話には欠かせませんな!</li>
<li>Nice for IRC</li>
</ul>

</div>

<div class="slide">
<h1>MooseX::POE</h1>

<pre><code>
package Counter;
use MooseX::POE;

has count => (
    isa     => 'Int',
    is      => 'rw',
);

sub START {
    my ($self) = @_;
    $self->yield('increment');
}

event increment => sub {
    my ($self) = @_;
    warn "Count is now " . $self->count;
    $self->count( $self->count + 1 );
    $self->yield('increment') unless $self->count > 3;
};

Counter->new( count => 0 );
POE::Kernel->run();
</code></pre>

<ul>
<li>POE のコンポーネントを簡単にかけます</li>
<li>POE components made easy</li>
<li>それぞれのオブジェクトが POE::Session をもってます</li>
<li>Every object has a POE::Session</li>
<li><code>event</code> がオブジェクトのステートを宣言します</li>
<li><code>event</code> declares object states</li>
</ul>

</div>

<div class="slide">
<h1>Fin</h1>

<ul>
<li><p>Slides written by:</p>

<ul>
<li>Chris Prather</li>
<li>Stevan Little</li>
<li>Robert Boone</li>
</ul></li>
<li><p>Slides deleted by:</p>

<ul>
<li>Yuval Kogman</li>
</ul></li>
<li><p>Slides translated by:</p>

<ul>
<li>tokuhirom</li>
</ul></li>
</ul>

</div>


</div>

</body>
</html>
