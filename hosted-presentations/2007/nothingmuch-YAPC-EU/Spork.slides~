----
presentation_topic: meta meta meta meta
presentation_title: Object Meta Programming
presentation_place: YAPC::EU::2007
presentation_date: Aug 29, 2007
----
= HAI FRENDS
{image:http://personal.inet.fi/taide/junttila/desert/2002/promopi.jpg}
== My name is Yuval
----
= Meta Programming
{image: http://www.prints.co.nz/Merchant2/graphics/00000001/7104_Squares_with_Concentric_Circles_Kandinsky_Wassily.jpg}
----
= Introduction
{image: http://www.room101.net/door.jpg}
+* Meta programming
+* writing /code/ which /outputs/ or /manipulates/ /code/
----
= Many forms
{image: http://www.internationalhero.co.uk/m/manimal.jpg}
+* string `eval`
+* `%::`
+* closure generators
+* macros
+* real macros
+* compilers
----
= Many forms
{image: http://www.junjan.org/weblog/images/Flying_Spaghetti_Monster-thumb.jpg}
+* Home grown snippets
+* Home grown packages
+* Stuff on the CPAN (e.g. `Class::Accessor`, `Code::Perl`)
+* Large systems (`Template::Toolkit`)
----
= Summary
{image: http://www.evc.org/programs/TD_web_projects/westside_amy_2003_1/teen_times/peerpressure/images/16_peer_pressure_smoking.gif}
* You should already know it
* You probably do it
+* That's the intended audience anyway ;-)
----
= Object Meta Programming
----
= Object Meta Programming
+* Code that outputs or manipulates /object oriented code/
+* Often written in OO
----
= Simple Examples
{image: http://www.wildoats.com/content/ApplePieSlice.jpg}
+* `Class::Accessor`, `Class::InsideOut`
+** Generates accessor methods
+* `Class::Prototyped`
+** Prototype object support in Perl
+* Lots of stuff on the CPAN
----
= Modeling OO
{image: http://www.nordicsubs.co.uk/covers/vogue.jpg}
+* High level object meta programming
+** The current trend
+** The picture illustrates an object modelling with class =)
+** Seriously though...
----
= Modeling OO
{image: http://www.nordicsubs.co.uk/covers/vogue.jpg}
* High level object meta programming
* What is a class?
+.vim
filetype: perl6

  class Class {
    has @isa;
    has %methods;
    has %attributes;

    ...
  }
.vim
----
= Modeling OO
{image: http://www.nordicsubs.co.uk/covers/vogue.jpg}
+* Implementing OO
+** In OO
+* Meta objects:
+** Class
+** Method
+** Attribute
----
= Example class

.vim
filetype: perl6

  class Point {
    has $x;
    has $y;

    method distance_to { ... }
  }
.vim
----
= Modeled with objects

.vim
filetype: perl

  Class->new(
    attributes => [
      Attribute->new( name => '$x' ),
      Attribute->new( name => '$y' ),
    ],
    methods => [
      Method->new(
        name       => "distance_to",
        definition => sub { ... }
      ),
    ],
  );
.vim
----
= Metamodel Services
{image: http://www1.istockphoto.com/file_thumbview_approve/944779/2/istockphoto_944779_reception_bell.jpg}
+* Form
+** Introspection/Reflection
+* Function
+** Class generation
+** Class transformation
+* Pattern packaging
----
= Case Study
{image: http://www.iinteractive.com/moose/images/a_moose.gif}
== Moose
+* A deep meta object system
+* 4 layers deep
+** Syntactic sugar
+** Custom metaclasses
+** Class::MOP
+** Perl's native OO
----
= Perl's native OO
{image: http://www.mileslight.com/images/perl-camel.gif}
+* Minimalistic
+** Class = Package = Symbol table hash
** Inheritence tree embedded in `@ISA` entry
** `bless` links data to a class
** `->`
+* Insanely flexible
+* Pretty klunky
+* Written in C (not very accessible)
----
= Class::MOP
{image: http://nothingmuch.woobling.org/MOP.jpg}
+* port of CLOS, more or less
+* MOP = Meta Object Protocol
----
= Class::MOP
{image: http://nothingmuch.woobling.org/MOP.jpg}
+* Model
+** `Class::MOP::Class`
** `Class::MOP::Method`
** `Class::MOP::Attribute`
+* Easy interface
+** Introspection
+** Transformation
----
= Class::MOP
{image: http://nothingmuch.woobling.org/MOP.jpg}
+* Can "parse" packages into meta objects
+* Modifying the objects writes back to packages
+* Code generation
+** Accessors from attributes
+** Constructor from attributes
+** Method modifiers
----
= Moose's custom metaclasses
{image: http://www.iinteractive.com/moose/images/a_moose.gif}
+* Subclasses of `Class::MOP::Class` et al
+* More fun features
+** Roles
+** `BUILD` etc a la Perl 6
+* Type constraints
----
= Moose sugar layer
{image: http://nothingmuch.woobling.org/sugar.jpg}
+* Pseudo-declarative syntax
+* Maps to metaclass manipulations
+.vim
  has foo => ( is => "rw" );
.vim
+* becomes
+.vim
  $metaclass->add_attribute(
    Moose::Meta::Attribute->new(
      foo => ( is => "rw" ),
    )
  );
.vim
----
= Moose vs. Class::Accessor
{image: http://nothingmuch.woobling.org/p-seal-at-toronto-zoo.jpg}
+* All that bloat just for the `has` syntax?
+* *NO!*
+* Pattern packaging
----
= MooseX::
{image: http://www.threadpit.com/photos/all_styles/small/401.jpg}
+* Packaged meta code
+* Pretty clean
+* Mostly composable
----
= MooseX::
{image: http://www.threadpit.com/photos/all_styles/small/401.jpg}
+* `MooseX::Storage`
+** Customizable serialization through metaprogramming
+* `MooseX::AttributeHelpers`
+** Additional methods for collection type attributes
+* `MooseX::Getopt`
+** Additional constructor compiles attributes into a `Getopt` spec
+* `MooseX::IOC`
+** Inversion of control integrated into the object system
----
= The point of Moose
{image: http://nothingmuch.woobling.org/cute_moose.jpg}
+* OO is less tedious
+* Helps you write meta code
+** Good APIs promote clean code
+** Easier to build on existing base
+** Conventions and structure let you play well with others (`MooseX::`)
+** Introspectable & tranformable metamodel
----
= Another Case Study
{image: http://www.rockies-ice.com/images/MainHeaderPic_5.gif}
== ORMs
+* Are *HARD*
+* Not even fun like the picture
----
= ORMs
{image: http://www.agiledata.org/images/legacyDataSources.jpg}
+* Modeling
+** Tables <-> Classes
+** Fields <-> Attributes
+* Code Generation
+** SQL
+** Accessors
+** Relationship fetchers
----
= `Class::DBI`
+* Meta code is in the base class
+* No clear schema modelling
+* No separation between regular & meta code
+* Lots of hacks
+* Don't go there
----
= `DBIx::Class`
+* Meta enlightened
+** Schema objects fully model the SQL side
+** ResultSource etc partially model the OO side
+** Components for everything
----
= `DBIx::Class`
+* Meta code:
+** Proxy objects
+** Accessors
+** Code generation (SQL, Perl)
----
= ORM related meta programming
+* Complex
+* But manageable
----
= Vaporware
{image: http://www.nzgeothermal.org.nz/geothermal_energy/images/big/b-silencer-water-vapour.jpg}
----
= MO
{image: http://www.nzgeothermal.org.nz/geothermal_energy/images/big/b-silencer-water-vapour.jpg}
+* My baby
+* Moose spinoff
+** Stevan says it's Moose 2.0's
+* Perl 5 & Haskell (in pugs)
----
= MO Sucks
{image: http://www5f.biglobe.ne.jp/~tantan-kids/I.syokuzai/lollypop.jpg}
+* Experimental code
+* Boring parts messy or unwritten
+* Lacking integration, sugar layer
+** mst promised to help ;-)
+* Some parts slow as $*!&%
----
= MO Rocks
{image: http://nothingmuch.woobling.org/rocks.jpg}
+* Purely functional
+* Very suited for meta transformations
+* Fine grained control over everything
+* Can introduce entirely new conceptions of OO
----
= MO Architechture
{image: http://www.narrabay.com/images/engineering_large.jpg}
+* Modeling layer
+** Corresponds to compilation
+* Responder layer
+** Corresponds to runtime
----
= MO Architechture
{image: http://www.narrabay.com/images/engineering_large.jpg}
+* Compiler/sugar layer creates the modeling layer
+** Class objects are constructed, with all the details
+** No meta calculations happen yet
+* Modeling layer is "compiled" into responder layer
+** Can be done on demand or upfront
+* Obscurely named objects
+** Bear with me
----
= "Concepts"
{image: http://gallery.hd.org/_exhibits/light/_more2003/_more05/light-bulb-glowing-filament-light-blue-uncropped-lores-3-AHD.jpg}
+* The purest form of OO is prototypes
+** prototype OO can implement class OO
+* Concepts are new ways to express objects
+* A class is a concept
+* A role is a concept
----
= "Responder Interfaces"
{image: http://www.cs.usfca.edu/~parrt/course/652/lectures/images/vtable.jpg}
+* `$ri->dispatch( $responder, $invocation )`
+* Generated from concepts
+* Abstract VTable
+** The flattened method hierarchy
+** ... or something completely different
+** Performance
+** Flexibility
----
= "Responders"
{image: http://www.maine.gov/spo/flood/images/fema_seal.gif}
+* Something that is the subject of invocations
+** An object instance
+** A class (class methods)
+* A simple tuple `( $data, $ri )`
----
= "Invocations"
{image: http://www.mobilenews.sk/wp-content/lg-banana.jpg}
+* A method call, multimethod, message... whatever
+** Arguments, too
+* Whatever an RI will put up with
+** Extensible calling semantics
----
= MO compilation flow
{image: http://www.daveltd.com/photo/rolls/digital/water/waterfalls/snoqualmie-falls/snoqualmie-falls-flowing-3811-equalized.jpg}
+* Instantiate a `Class` object
+** Specify members (methods, attributes)
+** ... and ancestor classes & roles
+* Compile class
+** `my $class_methods_ri = $class->class_interface()`
+** Instance method RI closed in the constructor, within `$ri`
+** Purely functional operation 
----
= RI composition
{image: http://www.daveltd.com/photo/rolls/digital/water/waterfalls/snoqualmie-falls/snoqualmie-falls-flowing-3811-equalized.jpg}
+* Compute instance methods and attributes from ancestry
+* Compute instance slots from attributes
+* Generate accessors
+.vim
  MO::Run::ResponderInterface::MethodTable->new(
    methods => %methods
  );
.vim
+* Generate constructor
+.vim
  sub {
    my $data = process_params(@_);
    return box( $data, $instance_ri );
  }
.vim
----
= Instantiation
{image: http://d6044171.u109.worldispnetwork.com/images/Creation-hands-L.jpg}
+* Lookup RI using class name
+* Dispatch constructor class method
+* Compose data from params
+** Slightly complicated
+* Link data with closed `$instance_ri`
+** Responder == ( Data, RI )
+** Like `bless`
----
= Method calls
{image: http://www.w3.org/2005/Talks/05-maxf-xtech/telephone.jpg}
+* How to talk with your new object?
+.vim
  my $ri = $responder->responder_interface;


+  my $method = MO::Run::Invocation::Method->new(
    name      => "foo"
    arguments => \@blah,
  );


+  $ri->dispatch( $responder, $method );
.vim
+* Arbitrary responder interfaces also allowed
+** Doesn't have to be `$responder->responder_interface`
----
= OH NOES!!!
{image: http://www.encyclopediadramatica.com/images/f/f5/Surprise-buttsecks.jpg}
+* What's wrong with the previous slide?
+* RIs are objects too!
+* Need to bootstrap method calls
+* Runtime must bootstrap low level OO
+** More on this soon
----
= Meta level polymorphism
{image: http://www.worth1000.com/entries/44500/44790qV87_w.jpg}
+* An important point
+** In fact, *the* point of MO
+* Responder interfaces are polymorphic
+** Method table, network proxy, whatever
+* Easy to specialize
+** Optimizations
+** Strange features
+* Easy to mix several OO systems
+** Just compile to separate RIs
----
= MO in Perl 5
{image: http://www.vetaid.org/assets/shop/card-camel-108.jpg}
+* Two runtimes
+* Very different
+* `MO::Run::Aux` wraps both
+** Share tests by running with different `%ENV` var
----
= Hosted runtime
{image: http://www.philnjill.com/collections/kubricks/kub_alien/S2Secret.jpg}
+* Nested object system
+* Bootstraps with Perl 5
+** Native Perl OO == Low level, like VM opcodes
+** Virtualized MO == High Level
+** Completely separate levels
+* `$ri->dispatch( $responder, $method )`
+** not `$responder->$method()`
+* Full expressiveness
+* Slow, verbose
----
= Native runtime
{image: http://www.sonofthesouth.net/american-indians/pictures/indian-camp.jpg}
+* Integrated object system
+* RIs are compiled into packages
+** Simple RIs are dissassembled and stuffed into the stash
+** Complex RIs use `AUTOLOAD`, delegating to the RI meta object
+* Only named method calls
+** No arbitrary call concepts
+** `->` doesn't support anything else
+* As fast as "regular" Perl OO
+** Even makes simple, standalone `.pmc`s
----
= Perl 5 Runtimes
+* Native
+** Usable with regular Perl OO {html:&#9786;}
+** Lacks arbitrary invocations {html:&#9785;} 
+* Virtualized
+** Feature complete {html:&#9786;}
+** Doesn't integrate {html:&#9785;}
+** Slow {html:&#9785;}
----
= Idealized MO toolchain
{image: http://www.ibiblio.org/wm/paint/auth/botticelli/botticelli.venus.jpg}
+* Compiler handles modeling
+** Constructs meta objects at compile time
+* VM Opcodes support standard RI
+* Custom RIs are just objects
+** Bootstrapped using standard runtime objects
+*** Method table RI
+*** Named method invocation
----
= Perl 6
{image: http://lolgeeks.com/wp-content/uploads/2007/05/lolgeeks016.jpg}
+* Perl 6 is the idealized MO toolchain
+** Can introduce syntax
+*** Invocation types
+*** Concept declarations
+** Implement bootstrap RIs in VM opcodes
+* Pugs might be using MO
+** I'm not really sure
+** It was ported a while ago
----
= Introducing new concepts
+* Roles are the shit
+* But what about next week's fad?
+* MO lets you introduce a new concept
+** Arbitrary at compile time
+** RI protocol at runtime
----
= Example - Prototype Objects
+* One shared RI
.vim
  sub dispatch {
    my ( $object, $invocation ) = @_;

    my $method = $object->{ $invocation->name };

    $object->$method( $invocation->arguments );
  }
.vim
----
= Example - Attribute Grammars
{image: http://nothingmuch.woobling.org/village_people.jpg}
+* Crazy stuff from the 1970s
+* Renewed interest in {html:&lambda;} land 
+* Was pretty easy in MO
----
= Attribute Grammer Implementation
{image: http://grammar.ccc.commnet.edu/grammar/images/grammar.gif}
+* Introduce new concept objects
+** Attribute Grammar
+** Attribute Grammer Instance - one per AG per class
+* Runtime specialized RI
+** Shadows any RI with additional context sensitive methods
+* Additional runtime support code
----
= MO TODO
{image: http://www.constructionownerslawblog.com/checklist.jpg}
+* Write a sugar layer
+** Make it fun to use
+* Tests
+* Refactor the Class objects
+** Bloated example code
+** There are some patterns to extract
+* Self hosting
----
= Self Hosting
+* Easier to maintain MO written in Moose
+* Need to have clean syntax
+* Stable `.pmc` compilation
----
= Conclusion
{image: http://www1.istockphoto.com/file_thumbview_approve/2540021/2/istockphoto_2540021_painted_exclamation_mark.jpg}
+* Meta code is awesome code
+** Especially my meta code ;-)
----
= Conclusion
{image: http://www1.istockphoto.com/file_thumbview_approve/2540021/2/istockphoto_2540021_painted_exclamation_mark.jpg}
* Meta code is awesome code
+** Lets you program in new ways
+** Helps you take care of your other code
+* Meta code is important code
+** It can affect *anything*
+** Keep it minimalistic, and clearly defined
+** No spaghetti monsters
+* Meta code can be simple
+** Only complicated if you aren't careful
----
= BIE FRENDS
{image: http://www.girlscoutsofblackhawk.org/Portals/0/webphotos/thanks.jpg}
